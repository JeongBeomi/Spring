## 0. 목차
- 회원 리포지토리 개발
- 회원 서비스 개발
- 회원 기능 테스트

## 1. 회원 리포지토리 개발
### 1-1. 구현기능
- 회원 등록
- 회원 목록 조회

### 1-2. 회원 리포지토리 코드
- repository/MamberRepository
  ```java
  @Repository // 컨포넌트 스캔에 의해 자동으로 스프링 빈으로 관리됨
  @RequiredArgsConstructor // 회원 서비스 코드에서 자세히 설명
  public class MemberRepository {
      /*
      @PersistenceContext //JPA가 제공하는 표준 어노테이션
      private EntityManager em;
      spring이 해당 엔티티매니저를 만들어서 주입해줌 코드로 생각하면
      Public MemeberRepository(EntityManager em) {
          this.em= em;
      }
      Lombok의 @RequiredArgsContsructor 를 사용하면 더욱 간단해짐
      */
      private final EntityManager em;

      public void save(Member member) {
          em.persist(member);
          /*
          persist하면 영속성 컨텍스트에 일단 member객체를 넣는다
          나중에 트랜잭션이 커밋되는 시점에 DB에 반영된다.
          */
      }

      public Member findOne(Long id) {
          return em.find(Member.class, id);
          // 단권조회, JPA의 find메서드 사용
      }

      public List<Member> findAll() {
          //JPQL을 작성해야 함
          // 첫번째 파라미터에 jpql을 쓰고 두번째에 반환 탑입을 쓴다.
          /*
          List<Member> result = em.createQuery("select m from Member m", Member.class)
                  .getResultList(); 
                  // 변수 단축키 ctrl + alt + v
          return result;
          */

          //  한줄로 줄일때 inline variable 단축키 ctrl + alt + n
          return em.createQuery("select m from Member m", Member.class)
                  .getResultList();
          // sql은 테이블을 대상으로 쿼리를 하지만, jpql은 엔티티 객체를 대상으로 쿼리한다
      }

      public List<Member> findByName(String name) {
          return em.createQuery("select m from Member m where m.name = :name", Member.class)
                  .setParameter("name", name) // 위의 :name에 파라미터 바인딩
                  .getResultList();
      }
  }
  ```
- 기술 설명
  - @Repository : 스프링 빈으로 등록, JPA 예외를 스프링 기반 예외로 예외 변환
  - @PersistenceContext : 엔티티 메니저( EntityManager ) 주입
  - @PersistenceUnit : 엔티티 메니터 팩토리( EntityManagerFactory ) 주입

## 2. 회원 서비스 개발

### 2-1. 회원 서비스 코드
  - service/MemberService
  ```java
  @Service // 컨포넌트 스캔에 의해 자동으로 스프링 빈으로 관리됨
  //JPA의 어떤 모든 데이터 변경이나 로직들은 가급적이면 트랜잭션안에서 처리되야한다.
  @Transactional(readOnly = true) // 쓸수 있는 옵션이 많기때문에 spring의 어노테이션 사용 지향
  @RequiredArgsConstructor
  public class MemberService {

      /*
      1. 필드인젝션
      @Autowired //필드인젝션, 인젝션에는 여러방법이 있지만 지금은 이방법으로
      private MemberRepository memberRepository;

      필드인젝션에 private이기 때문에 변경을 못하는 등 다양한 단점 존재
      아래처럼 setter 인젝션을 한다 스프링이 바로 주입하는게 아니라 메서드를 거쳐 주입
      테스트코드를 작성할 때 Mock()을 직접 주입할 수 있다
       */
      /*
      2. 세터인젝션
      private MemberRepository memberRepository;
      @Autowired
      // Generate 단축키 alt + Insert -> setter
      public void setMemberRepository(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
      but 개발시 setMemeberRepository(member)를 호출해서 바꿀 일이 있을까? -> 없다 애플리케이션 로딩시점에 조립이 끝남
      그렇게되면 setter인젝션 안좋음
      -> 궁극적으로 요즘 권장박식은 생성자 인젝션
      */

      /*
      3. 생성자 인젝션
      alt + Insert -> contructor
      생성자에서 인젝션을 해준다 -> 생성할때 완성이되어버림 중간에 set으로 memberRepository를 바꿀수없다
      테스트케이스 작성할때 Mock()같은 값을 주입해줘여한다 생성시점에 얘는 이게필요해 의존하고 있어라는 것을
      명확하게 알 수 있다.
      public static void main(String[] args) { //main함수 단축어 psvm
          MemberService memberService = new MemberService(Mock());
      }
      private MemberRepository memberRepository;
      @Autowired
      public MemberService(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
      */

      /*
      4. final
      변경할 일이 없기 때문에 final로 하는 것을 권장
      생성자 값 세팅을 안하면 에러 빨간줄 발생 -> 컴파일 시점을 체크할 수 있다.
      private final MemberRepository memberRepository;
      @Autowired
      public MemberService(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
      여기서 롬복을 적용하면 @AllArgsConstructor을 붙이면 모든 필드의
      @Autowired
      public MemberService(MemberRepository memberRepository) {
          this.memberRepository = memberRepository;
      }
      을 만들어 준다. 그런데 이거보다 조금더 나아가면 @RequiredArgsConstructor
      final로 설정된 필드만 가지고 생성자를 만들어준다
       */
      private final MemberRepository memberRepository;

      //회원 가입
      @Transactional // 쓰기니까 readOnly = true 금지
      public Long join(Member member) {
          validateDuplicateMember(member); //중복 회원 검증
          memberRepository.save(member);
          //위 save 메서드애서 persist하는 순간 DB에 저장되지 않아도 pk가 존재한다
          return member.getId();
      }

      private void validateDuplicateMember(Member member) {
          //EXCEPTION
          List<Member> findMembers = memberRepository.findByName(member.getName());
          if (!findMembers.isEmpty()) {
              throw new IllegalStateException("이미 존재하는 회원입니다.");
          }
          /*
          유효성검사를 이렇게 진행하더라도 동시에 데이터를 입력하면 통과할 수 있다.
          최후의 방어선으로 name을 유니크값으로 넣는다.
           */
      }

      //회원 전체 조회
      //@Transactional(readOnly = true)를 하면 조회하는 성능 최적화
      //단 읽기에서만 사용 쓰기인 경우에는 절대 넣어선 안된다. 데이터변경안됨
      public List<Member> findMembers() {
          return memberRepository.findAll();
      }

      //회원 한건 조회
      public Member findOne(Long memberId) {
          return memberRepository.findOne(memberId);
      }
  }
  ```

- 기술 설명
  - @Service : 컨포넌트 스캔에 의해 자동으로 스프링 빈으로 관리됨
  - @Transactional : 트랜잭션, 영속성 컨텍스트
  - readOnly=true : 데이터의 변경이 없는 읽기 전용 메서드에 사용, 영속성 컨텍스트를 플러시 하지 않으므로 약간의 성능 향상(읽기 전용에는 다 적용)
    데이터베이스 드라이버가 지원하면 DB에서 성능 향상

- 필드주입보다는 생성자 주입을 사용
    
    1. 필드인젝션
        ```java
        @Autowired //필드인젝션, 인젝션에는 여러방법이 있지만 지금은 이방법으로
        private MemberRepository memberRepository;
        ```
       - 필드인젝션에 private이기 때문에 변경을 못하는 등 다양한 단점 존재
       - 아래처럼 setter 인젝션을 한다 스프링이 바로 주입하는게 아니라 메서드를 거쳐 주입
       - 테스트코드를 작성할 때 Mock()을 직접 주입할 수 있다
    
    2. 세터인젝션
        ```java
        private MemberRepository memberRepository;
        @Autowired
        // Generate 단축키 alt + Insert -> setter
        public void setMemberRepository(MemberRepository memberRepository) {
            this.memberRepository = memberRepository;
        }
        ```
        - but 개발시 setMemeberRepository(member)를 호출해서 바꿀 일이 있을까?
        - 없다 애플리케이션 로딩시점에 조립이 끝남 이렇게 되면 setter인젝션 안좋음
        - -> 궁극적으로 요즘 권장방식은 생성자 인젝션
        ```

    3. 생성자 인젝션(단축키 : alt + Insert -> contructor)
       - 생성자에서 인젝션을 해준다 -> 생성할때 완성이되어버림 중간에 set으로 memberRepository를 바꿀수없다
           ```java
           private MemberRepository memberRepository;
           @Autowired
           public MemberService(MemberRepository memberRepository) {
               this.memberRepository = memberRepository;
           }
           ```
       - 테스트케이스 작성할때 Mock()같은 값을 주입해줘야 한다
       - 생성시점에 얘는 이게필요해 의존하고 있어라는 것을 명확하게 알 수 있다.
           ```java
           public static void main(String[] args) { //main함수 단축어 psvm
               MemberService memberService = new MemberService(Mock());
           }
           ```

    4. final
       - 변경할 일이 없기 때문에 final로 하는 것을 권장
       - 생성자 값 세팅을 안하면 에러 빨간줄 발생 -> 컴파일 시점을 체크할 수 있다.
           ```java
           private final MemberRepository memberRepository;
           @Autowired
           public MemberService(MemberRepository memberRepository) {
               this.memberRepository = memberRepository;
           }
           ```
       - 여기서 롬복을 적용하면 @AllArgsConstructor을 붙이면 모든 필드에 대해 아래 코드를 만들어 준다
           ```java
           @Autowired
           public MemberService(MemberRepository memberRepository) {
               this.memberRepository = memberRepository;
           }
           ```
       - 그런데 이거보다 조금더 나아가면 @RequiredArgsConstructor
       - final로 설정된 필드만 가지고 생성자를 만들어준다
           ```java
           @RequiredArgsConstructor
           public class MemberService {
               private final MemberRepository memberRepository;

               ...
           }
           ```
    > 참고: 스프링 데이터 JPA를 사용하면 EntityManager 도 주입 가능
    ```java
    // repository/MemberRepository
    @Repository
    @RequiredArgsConstructor
    public class MemberRepository {
        private final EntityManager em;
        ...
    }
    ```

## 3. 회원기능 테스트
### 3-1. 테스트 요구사항
- 회원가입을 성공해야 한다.
- 회원가입 할 때 같은 이름이 있으면 예외가 발생해야 한다.

### 3-2. 회원가입 테스트 코드
- MemberService에서 테스크 코드를 생성
  ```java
  public class MemeberService // 여기서 단축키 Ctrl + Shift + T ->create new test 
  { 
    ...
  }
  ```
  
