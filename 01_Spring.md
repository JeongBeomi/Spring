# 0. 목차


# 1. 스프링이란?
![image](https://user-images.githubusercontent.com/109258397/220018119-5847ee21-fd8d-404e-8e64-c5627a8b0c7e.png)

## 1-1. 스프링 프레임워크
- 핵심기술 : 스프링DI컨터이너, AOP, 기타
- 웹기술 : 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술 : 트랜잭션, JDBC, ORM지원, XML지원
- 기술 통합 : 캐시, 이메일, 원격접근, 스케줄링
- 테스트 : 스프링 기반 테스트 지원
- 언어 : 코틀린, 그루비
- 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용

## 1-2. 스프링 부트
- 스프링을 편리하개 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행 가능한 스프링 애플리케이션을 쉽게 생성
- Tomcat같은 웹서버를 내장해서 별도의 웹서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
   - (starter 종속성을 가져오면 관련 종속성을 모두 끌어와 설정을 편리하게 해줌. ex, starter-security를 설정하면 security관련 작업에 필요한 모든 의존성을 설정해준다.)
- 스프링과 3rd parth(외부) 라이브러리 자동 구성
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
- 관례에 의한 간결한 설정

## 1-3. 스프링 단어?
- 스프링이라는 단어는 문맥에 따라 다르게 사용
  - 스프링 DI컨테이너 (스프링 빈 관리)
  - 스프링 프레임워크
  - 스프링부트, 프레임워크 등을 모두 포함한 생태계 전체
- 스프링의 진짜핵심
  - 스프링은 자바 언어 기반의 프레임워크
  - 자바 언어의 가장 큰 특징 : 객체 지향 언어
  - 스프링은 객제 지향 언어가 가진 강력한 특징을 살려내는 프레임 워크

# 2. 객체 지향 프로그래밍이란?

## 2-1. 객체 지향 프로그래밍
- 컴퓨터 프로그램을 명령어의 목록이 아닌 여려개의 독립된 단위 인 "객체"들의 모임으로 파악, 각각의 개체는 메시지를 주고받고, 데이터 처리 가능
- 유연하고 변경이 용이하기 때문에 대규모 소프트웨어 개발에 많이 사용

## 2-1. 다형성
- 역할과 구현으로 구분한다.
- 자바 언어의 다현성을 활용
  - 역할 = 인터페이스 / 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체 설계시 역할과 구현을 명확히 분리
- 역할(인터페이스)을 먼저 부여, 그 역할을 수행하는 구현 객체 만들기

## 2-2. 객체의 협력이라는 관계
- 클라이언트 : 요청, 서버 : 응답
- 수많은 객체 클랑이언트와 객체 서버는 서로 협렵 관계를 가진다.
![image](https://user-images.githubusercontent.com/109258397/220041636-aeaa558a-bbfe-474a-ad27-5737f53b34ba.png)
- 다형성의 본질
  - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경
  ![image](https://user-images.githubusercontent.com/109258397/220042547-c6290adf-4b07-45d5-885b-203666e9d57d.png)
  - 다형성의 본질을 이해하려면 협력이라는 객체사이의 관계에서 시작해야함
  - 클라이언트를 변경하지 않고, 서버의 구현기능을 유연하게 변경 가능
- 역할과 구현 분리의 한계
  - 역할(인터페이스)자체가 변하면 클라이언트, 서버 모두에 큰 변경 발생
  - 인터페이스를 안정적으로 잘 설계하는 것이 중요

## 2-3. 스프링과 객체 지향
- 다형성이 가장 중요
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와줌
- 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해 역할과 구현을 편리하게 다룰 수 있도록 지원

# 3. 좋은 객체 지향 설계의 5가지 원칙 (SOLID)
## 3-1. SOLID
- SRP : 단일 책임 원칙(single responsibility principle)
  - 한 클래스는 하나의 책임만 가져야 한다
  - 하나의 책임이라는 것은 모호하다
    - 문맥과 상황에 따라 다르다
    - 클 수 있고, 작을 수 있다
  - 중요한 기준은 **변경**이다 -> 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른것
  - ex) UI변경, 객체의 생성과 사용을 분리
- OCP : 개방-폐쇄 원칙(Open/closed principle)
  - 소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다
  - 다형성을 활용
  - 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현

- LSP : 리스코프 치환 원칙(Liskov substitution principle)
- ISP : 인터페이스 분리 원칙(Interface segregation principle)
- DIP : 의존관계 역전 원칙(Dependency inversion principle)
